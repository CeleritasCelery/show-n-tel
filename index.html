<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show-N-Tel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: white;
        min-height: 100vh;
        color: #333;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
    }

    .header {
        text-align: center;
        margin-bottom: 3rem;
        color: #666;
    }

    .header h1 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        font-weight: 700;
        color: #333;
    }

    .header p {
        font-size: 1.1rem;
        opacity: 0.8;
        font-weight: 400;
    }

    .search-section {
        background: white;
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        margin-bottom: 2rem;
    }

    .search-form {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .url-input {
        flex: 1;
        padding: 1rem 1.5rem;
        border: 2px solid #e1e5e9;
        border-radius: 12px;
        font-size: 1rem;
        transition: all 0.3s ease;
    }

    .url-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .search-btn {
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
    }

    .search-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .search-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .bookmarklet-section {
        text-align: center;
        margin-top: 1rem;
    }

    .bookmarklet-btn {
        padding: 0.75rem 1.5rem;
        background: #f8f9fa;
        color: #333;
        border: 2px solid #e1e5e9;
        border-radius: 12px;
        font-size: 0.9rem;
        font-weight: 500;
        cursor: pointer;
        transition: all 0.3s ease;
    }

    .bookmarklet-btn:hover {
        background: #e9ecef;
        border-color: #adb5bd;
    }

    .modal {
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0,0,0,0.5);
        display: flex;
        justify-content: center;
        align-items: center;
    }

    .modal-content {
        background: white;
        padding: 2rem;
        border-radius: 16px;
        max-width: 600px;
        width: 90%;
        max-height: 80vh;
        overflow-y: auto;
        position: relative;
        box-shadow: 0 20px 40px rgba(0,0,0,0.2);
    }

    .close {
        position: absolute;
        top: 1rem;
        right: 1.5rem;
        font-size: 2rem;
        cursor: pointer;
        color: #999;
        line-height: 1;
    }

    .close:hover {
        color: #333;
    }

    .modal-content h2 {
        margin-bottom: 1rem;
        color: #333;
    }

    .modal-content p {
        margin-bottom: 1.5rem;
        color: #666;
        line-height: 1.5;
    }

    .bookmarklet-code {
        background: #f8f9fa;
        border: 1px solid #e1e5e9;
        border-radius: 8px;
        padding: 1rem;
        margin-bottom: 2rem;
        position: relative;
    }

    .bookmarklet-code code {
        display: block;
        font-family: 'Courier New', monospace;
        font-size: 0.85rem;
        word-break: break-all;
        margin-bottom: 1rem;
        color: #333;
        line-height: 1.4;
    }

    .copy-btn {
        background: #667eea;
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 6px;
        font-size: 0.85rem;
        cursor: pointer;
        transition: background 0.3s ease;
    }

    .copy-btn:hover {
        background: #5a67d8;
    }

    .copy-btn.copied {
        background: #38a169;
    }

    .instructions {
        color: #333;
    }

    .instructions h3 {
        margin: 1.5rem 0 0.5rem 0;
        color: #333;
        font-size: 1.1rem;
    }

    .instructions ol, .instructions ul {
        margin-left: 1.5rem;
        line-height: 1.6;
    }

    .instructions li {
        margin-bottom: 0.5rem;
    }

    .loading {
        text-align: center;
        padding: 2rem;
        color: #666;
    }

    .spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 2rem;
    }

    .platform-section {
        background: white;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        transition: transform 0.3s ease;
    }

    .platform-section:hover {
        transform: translateY(-4px);
    }

    .platform-header {
        padding: 1.5rem;
        color: white;
        font-weight: bold;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .platform-header.hn {
        background: linear-gradient(135deg, #ff6600, #ff8533);
    }

    .platform-header.reddit {
        background: linear-gradient(135deg, #ff4500, #ff6633);
    }

    .platform-header.lobsters {
        background: linear-gradient(135deg, #990000, #cc0000);
    }

    .platform-results {
        max-height: 400px;
        overflow-y: auto;
    }

    .result-item {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #f0f0f0;
        transition: background-color 0.2s ease;
    }

    .result-item:hover {
        background-color: #f8f9fa;
    }

    .result-item:last-child {
        border-bottom: none;
    }

    .result-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
    }

    .result-title a {
        color: #333;
        text-decoration: none;
    }

    .result-title a:hover {
        color: #667eea;
    }

    .result-meta {
        font-size: 0.85rem;
        color: #666;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .no-results {
        padding: 2rem;
        text-align: center;
        color: #999;
        font-style: italic;
    }

    .error {
        background: #fee;
        color: #c33;
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
    }

    @media (max-width: 768px) {
        .search-form {
            flex-direction: column;
        }

        .results {
            grid-template-columns: 1fr;
        }

        .container {
            padding: 1rem;
        }

        .header h1 {
            font-size: 2rem;
        }
    }
</style>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Show-N-Tel</h1>
            <p>Find where any URL is being discussed across Hacker News, Reddit, and Lobsters</p>
        </div>

    <div class="search-section">
        <form class="search-form" id="searchForm">
            <input
                type="url"
                class="url-input"
                id="urlInput"
                placeholder="Enter a URL (e.g., https://example.com)"
                required
            >
            <button type="submit" class="search-btn" id="searchBtn">
                Search Discussions
            </button>
        </form>
        
        <div class="bookmarklet-section">
            <button class="bookmarklet-btn" id="bookmarkletBtn">
                üìö Get Bookmarklet
            </button>
        </div>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>Searching across platforms...</p>
    </div>

    <div id="results" class="results"></div>
    
    <!-- Bookmarklet Modal -->
    <div id="bookmarkletModal" class="modal" style="display: none;">
        <div class="modal-content">
            <span class="close" id="closeModal">&times;</span>
            <h2>üìö Show-N-Tel Bookmarklet</h2>
            <p>Add this bookmarklet to quickly search discussions for any page you're viewing!</p>
            
            <div class="bookmarklet-code">
                <code id="bookmarkletCode">javascript:(function(){window.open('https://show-n.tel?url='+encodeURIComponent(window.location.href),'_blank');})();</code>
                <button class="copy-btn" id="copyBtn">Copy</button>
            </div>
            
            <div class="instructions">
                <h3>How to set it up:</h3>
                <ol>
                    <li>Copy the code above by clicking the "Copy" button</li>
                    <li>Create a new bookmark in your browser</li>
                    <li>Paste the code as the URL/location of the bookmark</li>
                    <li>Name it "Show-N-Tel" or "Find Discussions"</li>
                </ol>
                
                <h3>How to use:</h3>
                <ul>
                    <li>Navigate to any webpage</li>
                    <li>Click your bookmarklet</li>
                    <li>It will open Show-N-Tel with that page's URL and start searching!</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<script>
    class URLDiscussionFinder {
        constructor() {
            this.form = document.getElementById('searchForm');
            this.urlInput = document.getElementById('urlInput');
            this.searchBtn = document.getElementById('searchBtn');
            this.loading = document.getElementById('loading');
            this.results = document.getElementById('results');
            this.bookmarkletBtn = document.getElementById('bookmarkletBtn');
            this.bookmarkletModal = document.getElementById('bookmarkletModal');
            this.closeModal = document.getElementById('closeModal');
            this.copyBtn = document.getElementById('copyBtn');

            this.form.addEventListener('submit', this.handleSearch.bind(this));
            this.bookmarkletBtn.addEventListener('click', this.showBookmarkletModal.bind(this));
            this.closeModal.addEventListener('click', this.hideBookmarkletModal.bind(this));
            this.copyBtn.addEventListener('click', this.copyBookmarklet.bind(this));
            
            // Close modal when clicking outside
            this.bookmarkletModal.addEventListener('click', (e) => {
                if (e.target === this.bookmarkletModal) {
                    this.hideBookmarkletModal();
                }
            });
            
            // Check for URL parameter on page load
            this.checkUrlParameter();
        }

        checkUrlParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlParam = urlParams.get('url');
            
            if (urlParam) {
                this.urlInput.value = urlParam;
                // Hide bookmarklet button since they're already using it
                this.bookmarkletBtn.style.display = 'none';
                // Auto-search if URL parameter is provided
                this.handleSearch(new Event('submit'));
            }
        }

        async handleSearch(e) {
            e.preventDefault();
            const url = this.urlInput.value.trim();
            if (!url) return;

            // Update URL parameter for bookmarking/sharing
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('url', url);
            window.history.replaceState({}, '', newUrl);

            this.showLoading();

            try {
                const [hnResults, redditResults, lobstersResults] = await Promise.all([
                    this.searchHackerNews(url),
                    this.searchReddit(url),
                    this.searchLobsters(url)
                ]);

                this.displayResults({
                    hackernews: hnResults,
                    reddit: redditResults,
                    lobsters: lobstersResults
                });
            } catch (error) {
                this.showError(error.message);
            }

            this.hideLoading();
        }

        async searchHackerNews(url) {
            try {
                // Prefer searching by URL attribute for better precision
                const response = await fetch(`https://hn.algolia.com/api/v1/search?tags=story&restrictSearchableAttributes=url&query=${encodeURIComponent(url)}`);
                const data = await response.json();

                let results = data.hits || [];

                // If nothing matched, loosen the query slightly by trying without restrictSearchableAttributes
                if (!results.length) {
                    const resp2 = await fetch(`https://hn.algolia.com/api/v1/search?tags=story&query=${encodeURIComponent(url)}`);
                    const data2 = await resp2.json();
                    results = data2.hits || [];
                }

                return results
                    .filter(hit => hit.url && this.urlsEqual(hit.url, url))
                    .map(hit => ({
                        title: hit.title,
                        url: `https://news.ycombinator.com/item?id=${hit.objectID}`,
                        points: hit.points,
                        comments: hit.num_comments,
                        author: hit.author,
                        created: new Date(hit.created_at).toLocaleDateString(),
                        created_timestamp: new Date(hit.created_at).getTime()
                    }))
                    .sort((a, b) => {
                        // Sort by date first (newest first)
                        if (b.created_timestamp !== a.created_timestamp) {
                            return b.created_timestamp - a.created_timestamp;
                        }
                        // If same date, sort by comments (most comments first)
                        return (b.comments || 0) - (a.comments || 0);
                    })
                    .slice(0, 10);
            } catch (error) {
                console.error('HN search error:', error);
                return [];
            }
        }

        async searchReddit(url) {
            try {
                const results = [];
                const seen = new Set();

                // Helper to add a child if it matches and is not duplicate
                const maybeAdd = (child) => {
                    if (!child || !child.data) return;
                    const d = child.data;
                    const isLinkMatch = !!(d.url && this.urlsEqual(d.url, url));
                    const isSelfMention = !!(d.is_self && typeof d.selftext === 'string' && this.textMentionsUrl(d.selftext, url));
                    if (!isLinkMatch && !isSelfMention) return;

                    const key = d.id || d.name || d.permalink;
                    if (key && !seen.has(key)) {
                        seen.add(key);
                        results.push({
                            title: d.title,
                            url: `https://reddit.com${d.permalink}`,
                            subreddit: d.subreddit,
                            score: d.score,
                            comments: d.num_comments,
                            author: d.author,
                            created: new Date(d.created_utc * 1000).toLocaleDateString(),
                            created_timestamp: d.created_utc * 1000
                        });
                    }
                };

                // Try exact match via info.json first (captures link posts only)
                try {
                    const response = await fetch(`https://www.reddit.com/api/info.json?url=${encodeURIComponent(url)}`);
                    const data = await response.json();
                    const children = (data && data.data && Array.isArray(data.data.children)) ? data.data.children : [];
                    children.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 1: search.json constrained to url field, captures link posts
                try {
                    const q = `url:\"${url}\"`;
                    const resp2 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(q)}&limit=25`);
                    const data2 = await resp2.json();
                    const children2 = (data2 && data2.data && Array.isArray(data2.data.children)) ? data2.data.children : [];
                    children2.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 2: text search for quoted URL to capture self/text posts that mention the URL
                try {
                    const quoted = `\"${url}\"`;
                    const resp3 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(quoted)}&limit=25&sort=new`);
                    const data3 = await resp3.json();
                    const children3 = (data3 && data3.data && Array.isArray(data3.data.children)) ? data3.data.children : [];
                    children3.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 3: if URL has a scheme, also try searching the scheme-less variant quoted
                try {
                    const urlNoScheme = url.replace(/^https?:\/\//i, '');
                    if (urlNoScheme && urlNoScheme !== url) {
                        const quotedNoScheme = `\"${urlNoScheme}\"`;
                        const resp4 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(quotedNoScheme)}&limit=25&sort=new`);
                        const data4 = await resp4.json();
                        const children4 = (data4 && data4.data && Array.isArray(data4.data.children)) ? data4.data.children : [];
                        children4.forEach(maybeAdd);
                    }
                } catch (_) {
                    // ignore
                }

                return results
                    .sort((a, b) => {
                        // Sort by date first (newest first)
                        if (b.created_timestamp !== a.created_timestamp) {
                            return b.created_timestamp - a.created_timestamp;
                        }
                        // If same date, sort by comments (most comments first)
                        return (b.comments || 0) - (a.comments || 0);
                    })
                    .slice(0, 10);
            } catch (error) {
                console.error('Reddit search error:', error);
                return [];
            }
        }

        async searchLobsters(url) {
            try {
                const domain = this.extractDomain(url);
                // Use a CORS-friendly proxy to fetch Lobsters domain JSON
                // Lobsters does not set CORS headers on JSON endpoints; r.jina.ai mirrors the content
                const endpoint = `https://r.jina.ai/http://lobste.rs/domains/${encodeURIComponent(domain)}.json`;
                const text = await fetch(endpoint).then(r => r.text());

                // r.jina.ai wraps the response in a readable format; extract the JSON array between [ and ]
                const start = text.indexOf('[');
                const end = text.lastIndexOf(']');
                if (start === -1 || end === -1 || end <= start) {
                    return [];
                }
                const data = JSON.parse(text.slice(start, end + 1));

                const exact = data.filter(item => item.url && this.urlsEqual(item.url, url));

                return exact
                    .map(item => ({
                        title: item.title,
                        url: item.short_id_url && item.short_id_url.startsWith('http') ? item.short_id_url : `https://lobste.rs${item.short_id_url || ''}`,
                        score: item.score,
                        comments: item.comment_count,
                        author: typeof item.submitter_user === 'string' ? item.submitter_user : (item.submitter_user && item.submitter_user.username) || '',
                        tags: item.tags,
                        created: new Date(item.created_at).toLocaleDateString(),
                        created_timestamp: new Date(item.created_at).getTime()
                    }))
                    .sort((a, b) => {
                        // Sort by date first (newest first)
                        if (b.created_timestamp !== a.created_timestamp) {
                            return b.created_timestamp - a.created_timestamp;
                        }
                        // If same date, sort by comments (most comments first)
                        return (b.comments || 0) - (a.comments || 0);
                    })
                    .slice(0, 10);
            } catch (error) {
                console.error('Lobsters search error:', error);
                return [];
            }
        }

        extractDomain(url) {
            try {
                const urlObj = new URL(url);
                return urlObj.hostname.replace(/^www\\./, '');
            } catch {
                return url;
            }
        }

        normalizeUrlForComparison(rawUrl) {
            try {
                const u = new URL(rawUrl);
                const hostname = u.hostname.replace(/^www\./, '').toLowerCase();
                // Normalize path: remove trailing slash except for root
                let pathname = u.pathname || '';
                if (pathname === '/') {
                    pathname = '';
                } else {
                    // Remove all trailing slashes without using regex to avoid escaping pitfalls
                    while (pathname.endsWith('/')) pathname = pathname.slice(0, -1);
                }
                const search = u.search || '';
                // Ignore hash fragments
                return `${hostname}${pathname}${search}`;
            } catch {
                // Best-effort: strip trailing slashes from a string
                let s = String(rawUrl || '');
                while (s.endsWith('/')) s = s.slice(0, -1);
                return s;
            }
        }

        urlsEqual(a, b) {
            return this.normalizeUrlForComparison(a) === this.normalizeUrlForComparison(b);
        }

        // Extract candidate URLs from free text and check if any equal the target url
        textMentionsUrl(text, targetUrl) {
            if (!text) return false;
            const domain = this.extractDomain(targetUrl).toLowerCase();
            const candidates = [];

            // 1) Absolute URLs
            const absRe = /(https?:\/\/[^\s)\]\}>'"`]+)/gi;
            for (const m of text.matchAll(absRe)) {
                candidates.push(m[1]);
            }
            
            // 2) www. or bare domain with path (only collect those matching the target domain to reduce noise)
            const bareRe = /(?:^|\s)((?:www\.)?[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?:\/[\w\-\.\/%#?=&+~:@]+)?)/g;
            for (const m of text.matchAll(bareRe)) {
                const s = (m[1] || '').trim();
                if (!s) continue;
                try {
                    // Deduce domain either via URL or naive split
                    let host = '';
                    try { host = new URL(s).hostname.toLowerCase(); } catch { host = s.split('/')[0].toLowerCase(); }
                    if (!host.includes(domain)) continue;
                    candidates.push(s);
                } catch {}
            }

            // Normalize candidates and compare
            for (const c of candidates) {
                // If candidate is scheme-less, temporarily add https:// to help URL parsing normalize properly
                const c2 = /^https?:\/\//i.test(c) ? c : `https://${c}`;
                if (this.urlsEqual(c2, targetUrl)) return true;
            }
            return false;
        }

        showLoading() {
            this.loading.style.display = 'block';
            this.results.innerHTML = '';
            this.searchBtn.disabled = true;
            this.searchBtn.textContent = 'Searching...';
        }

        hideLoading() {
            this.loading.style.display = 'none';
            this.searchBtn.disabled = false;
            this.searchBtn.textContent = 'Search Discussions';
        }

        showError(message) {
            this.results.innerHTML = `<div class="error">Error: ${message}</div>`;
        }

        displayResults(results) {
            // Hide bookmarklet button once results are displayed
            this.bookmarkletBtn.style.display = 'none';
            
            const platforms = [
                { key: 'hackernews', name: 'Hacker News', class: 'hn', icon: 'üì∞' },
                { key: 'reddit', name: 'Reddit', class: 'reddit', icon: 'ü§ñ' },
                { key: 'lobsters', name: 'Lobsters', class: 'lobsters', icon: 'ü¶û' }
            ];

            const html = platforms.map(platform => {
                const platformResults = results[platform.key] || [];

                return `
                    <div class="platform-section">
                        <div class="platform-header ${platform.class}">
                            <span>${platform.icon}</span>
                            ${platform.name} (${platformResults.length})
                        </div>
                        <div class="platform-results">
                            ${platformResults.length > 0
                                ? platformResults.map(result => this.renderResult(result, platform.key)).join('')
                                : '<div class="no-results">No discussions found</div>'
                            }
                        </div>
                    </div>
                `;
            }).join('');

            this.results.innerHTML = html;
        }

        renderResult(result, platform) {
            const meta = [];

            if (platform === 'hackernews') {
                meta.push(`${result.points} points`);
                meta.push(`${result.comments} comments`);
                meta.push(`by ${result.author}`);
            } else if (platform === 'reddit') {
                meta.push(`r/${result.subreddit}`);
                meta.push(`${result.score} upvotes`);
                meta.push(`${result.comments} comments`);
            } else if (platform === 'lobsters') {
                meta.push(`${result.score} points`);
                meta.push(`${result.comments} comments`);
                if (result.tags) meta.push(`tags: ${result.tags.join(', ')}`);
            }

            meta.push(result.created);

            return `
                <div class="result-item">
                    <div class="result-title">
                        <a href="${result.url}" target="_blank">${result.title}</a>
                    </div>
                    <div class="result-meta">
                        ${meta.map(item => `<span>${item}</span>`).join('')}
                    </div>
                </div>
            `;
        }

        showBookmarkletModal() {
            this.bookmarkletModal.style.display = 'flex';
        }

        hideBookmarkletModal() {
            this.bookmarkletModal.style.display = 'none';
        }

        async copyBookmarklet() {
            const bookmarkletCode = document.getElementById('bookmarkletCode').textContent;
            
            try {
                await navigator.clipboard.writeText(bookmarkletCode);
                this.copyBtn.textContent = 'Copied!';
                this.copyBtn.classList.add('copied');
                
                setTimeout(() => {
                    this.copyBtn.textContent = 'Copy';
                    this.copyBtn.classList.remove('copied');
                }, 2000);
            } catch (err) {
                // Fallback for browsers that don't support clipboard API
                const textArea = document.createElement('textarea');
                textArea.value = bookmarkletCode;
                document.body.appendChild(textArea);
                textArea.focus();
                textArea.select();
                
                try {
                    document.execCommand('copy');
                    this.copyBtn.textContent = 'Copied!';
                    this.copyBtn.classList.add('copied');
                    
                    setTimeout(() => {
                        this.copyBtn.textContent = 'Copy';
                        this.copyBtn.classList.remove('copied');
                    }, 2000);
                } catch (err) {
                    console.error('Failed to copy: ', err);
                }
                
                document.body.removeChild(textArea);
            }
        }
    }

    // Initialize the app
    new URLDiscussionFinder();
</script>

</body>
</html>

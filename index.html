<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Show-N-Tel</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: white;
        min-height: 100vh;
        color: #333;
    }

    .container {
        max-width: 1200px;
        margin: 0 auto;
        padding: 2rem;
    }

    .header {
        text-align: center;
        margin-bottom: 3rem;
        color: #666;
    }

    .header h1 {
        font-size: 2.5rem;
        margin-bottom: 0.5rem;
        text-shadow: 0 2px 4px rgba(0,0,0,0.3);
        font-weight: 700;
        color: #333;
    }

    .header p {
        font-size: 1.1rem;
        opacity: 0.8;
        font-weight: 400;
    }

    .search-section {
        background: white;
        border-radius: 20px;
        padding: 2rem;
        box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        margin-bottom: 2rem;
    }

    .search-form {
        display: flex;
        gap: 1rem;
        margin-bottom: 1rem;
    }

    .url-input {
        flex: 1;
        padding: 1rem 1.5rem;
        border: 2px solid #e1e5e9;
        border-radius: 12px;
        font-size: 1rem;
        transition: all 0.3s ease;
    }

    .url-input:focus {
        outline: none;
        border-color: #667eea;
        box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
    }

    .search-btn {
        padding: 1rem 2rem;
        background: linear-gradient(135deg, #667eea, #764ba2);
        color: white;
        border: none;
        border-radius: 12px;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s ease;
        white-space: nowrap;
    }

    .search-btn:hover:not(:disabled) {
        transform: translateY(-2px);
        box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
    }

    .search-btn:disabled {
        opacity: 0.6;
        cursor: not-allowed;
    }

    .loading {
        text-align: center;
        padding: 2rem;
        color: #666;
    }

    .spinner {
        display: inline-block;
        width: 30px;
        height: 30px;
        border: 3px solid #f3f3f3;
        border-top: 3px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin-bottom: 1rem;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .results {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
        gap: 2rem;
    }

    .platform-section {
        background: white;
        border-radius: 16px;
        overflow: hidden;
        box-shadow: 0 10px 30px rgba(0,0,0,0.1);
        transition: transform 0.3s ease;
    }

    .platform-section:hover {
        transform: translateY(-4px);
    }

    .platform-header {
        padding: 1.5rem;
        color: white;
        font-weight: bold;
        font-size: 1.1rem;
        display: flex;
        align-items: center;
        gap: 0.5rem;
    }

    .platform-header.hn {
        background: linear-gradient(135deg, #ff6600, #ff8533);
    }

    .platform-header.reddit {
        background: linear-gradient(135deg, #ff4500, #ff6633);
    }

    .platform-header.lobsters {
        background: linear-gradient(135deg, #990000, #cc0000);
    }

    .platform-results {
        max-height: 400px;
        overflow-y: auto;
    }

    .result-item {
        padding: 1rem 1.5rem;
        border-bottom: 1px solid #f0f0f0;
        transition: background-color 0.2s ease;
    }

    .result-item:hover {
        background-color: #f8f9fa;
    }

    .result-item:last-child {
        border-bottom: none;
    }

    .result-title {
        font-weight: 600;
        margin-bottom: 0.5rem;
    }

    .result-title a {
        color: #333;
        text-decoration: none;
    }

    .result-title a:hover {
        color: #667eea;
    }

    .result-meta {
        font-size: 0.85rem;
        color: #666;
        display: flex;
        gap: 1rem;
        flex-wrap: wrap;
    }

    .no-results {
        padding: 2rem;
        text-align: center;
        color: #999;
        font-style: italic;
    }

    .error {
        background: #fee;
        color: #c33;
        padding: 1rem;
        border-radius: 8px;
        margin-bottom: 1rem;
    }

    @media (max-width: 768px) {
        .search-form {
            flex-direction: column;
        }

        .results {
            grid-template-columns: 1fr;
        }

        .container {
            padding: 1rem;
        }

        .header h1 {
            font-size: 2rem;
        }
    }
</style>

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Show-N-Tel</h1>
            <p>Find where any URL is being discussed across Hacker News, Reddit, and Lobsters</p>
        </div>

    <div class="search-section">
        <form class="search-form" id="searchForm">
            <input
                type="url"
                class="url-input"
                id="urlInput"
                placeholder="Enter a URL (e.g., https://example.com)"
                required
            >
            <button type="submit" class="search-btn" id="searchBtn">
                Search Discussions
            </button>
        </form>
    </div>

    <div id="loading" class="loading" style="display: none;">
        <div class="spinner"></div>
        <p>Searching across platforms...</p>
    </div>

    <div id="results" class="results"></div>
</div>

<script>
    class URLDiscussionFinder {
        constructor() {
            this.form = document.getElementById('searchForm');
            this.urlInput = document.getElementById('urlInput');
            this.searchBtn = document.getElementById('searchBtn');
            this.loading = document.getElementById('loading');
            this.results = document.getElementById('results');

            this.form.addEventListener('submit', this.handleSearch.bind(this));
            
            // Check for URL parameter on page load
            this.checkUrlParameter();
        }

        checkUrlParameter() {
            const urlParams = new URLSearchParams(window.location.search);
            const urlParam = urlParams.get('url');
            
            if (urlParam) {
                this.urlInput.value = urlParam;
                // Auto-search if URL parameter is provided
                this.handleSearch(new Event('submit'));
            }
        }

        async handleSearch(e) {
            e.preventDefault();
            const url = this.urlInput.value.trim();
            if (!url) return;

            // Update URL parameter for bookmarking/sharing
            const newUrl = new URL(window.location);
            newUrl.searchParams.set('url', url);
            window.history.replaceState({}, '', newUrl);

            this.showLoading();

            try {
                const [hnResults, redditResults, lobstersResults] = await Promise.all([
                    this.searchHackerNews(url),
                    this.searchReddit(url),
                    this.searchLobsters(url)
                ]);

                this.displayResults({
                    hackernews: hnResults,
                    reddit: redditResults,
                    lobsters: lobstersResults
                });
            } catch (error) {
                this.showError(error.message);
            }

            this.hideLoading();
        }

        async searchHackerNews(url) {
            try {
                // Prefer searching by URL attribute for better precision
                const response = await fetch(`https://hn.algolia.com/api/v1/search?tags=story&restrictSearchableAttributes=url&query=${encodeURIComponent(url)}`);
                const data = await response.json();

                let results = data.hits || [];

                // If nothing matched, loosen the query slightly by trying without restrictSearchableAttributes
                if (!results.length) {
                    const resp2 = await fetch(`https://hn.algolia.com/api/v1/search?tags=story&query=${encodeURIComponent(url)}`);
                    const data2 = await resp2.json();
                    results = data2.hits || [];
                }

                return results
                    .filter(hit => hit.url && this.urlsEqual(hit.url, url))
                    .slice(0, 10)
                    .map(hit => ({
                        title: hit.title,
                        url: `https://news.ycombinator.com/item?id=${hit.objectID}`,
                        points: hit.points,
                        comments: hit.num_comments,
                        author: hit.author,
                        created: new Date(hit.created_at).toLocaleDateString()
                    }));
            } catch (error) {
                console.error('HN search error:', error);
                return [];
            }
        }

        async searchReddit(url) {
            try {
                const results = [];
                const seen = new Set();

                // Helper to add a child if it matches and is not duplicate
                const maybeAdd = (child) => {
                    if (!child || !child.data) return;
                    const d = child.data;
                    const isLinkMatch = !!(d.url && this.urlsEqual(d.url, url));
                    const isSelfMention = !!(d.is_self && typeof d.selftext === 'string' && this.textMentionsUrl(d.selftext, url));
                    if (!isLinkMatch && !isSelfMention) return;

                    const key = d.id || d.name || d.permalink;
                    if (key && !seen.has(key)) {
                        seen.add(key);
                        results.push({
                            title: d.title,
                            url: `https://reddit.com${d.permalink}`,
                            subreddit: d.subreddit,
                            score: d.score,
                            comments: d.num_comments,
                            author: d.author,
                            created: new Date(d.created_utc * 1000).toLocaleDateString()
                        });
                    }
                };

                // Try exact match via info.json first (captures link posts only)
                try {
                    const response = await fetch(`https://www.reddit.com/api/info.json?url=${encodeURIComponent(url)}`);
                    const data = await response.json();
                    const children = (data && data.data && Array.isArray(data.data.children)) ? data.data.children : [];
                    children.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 1: search.json constrained to url field, captures link posts
                try {
                    const q = `url:\"${url}\"`;
                    const resp2 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(q)}&limit=25`);
                    const data2 = await resp2.json();
                    const children2 = (data2 && data2.data && Array.isArray(data2.data.children)) ? data2.data.children : [];
                    children2.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 2: text search for quoted URL to capture self/text posts that mention the URL
                try {
                    const quoted = `\"${url}\"`;
                    const resp3 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(quoted)}&limit=25&sort=new`);
                    const data3 = await resp3.json();
                    const children3 = (data3 && data3.data && Array.isArray(data3.data.children)) ? data3.data.children : [];
                    children3.forEach(maybeAdd);
                } catch (_) {
                    // ignore
                }

                // Fallback 3: if URL has a scheme, also try searching the scheme-less variant quoted
                try {
                    const urlNoScheme = url.replace(/^https?:\/\//i, '');
                    if (urlNoScheme && urlNoScheme !== url) {
                        const quotedNoScheme = `\"${urlNoScheme}\"`;
                        const resp4 = await fetch(`https://www.reddit.com/search.json?q=${encodeURIComponent(quotedNoScheme)}&limit=25&sort=new`);
                        const data4 = await resp4.json();
                        const children4 = (data4 && data4.data && Array.isArray(data4.data.children)) ? data4.data.children : [];
                        children4.forEach(maybeAdd);
                    }
                } catch (_) {
                    // ignore
                }

                return results.slice(0, 10);
            } catch (error) {
                console.error('Reddit search error:', error);
                return [];
            }
        }

        async searchLobsters(url) {
            try {
                const domain = this.extractDomain(url);
                // Use a CORS-friendly proxy to fetch Lobsters domain JSON
                // Lobsters does not set CORS headers on JSON endpoints; r.jina.ai mirrors the content
                const endpoint = `https://r.jina.ai/http://lobste.rs/domains/${encodeURIComponent(domain)}.json`;
                const text = await fetch(endpoint).then(r => r.text());

                // r.jina.ai wraps the response in a readable format; extract the JSON array between [ and ]
                const start = text.indexOf('[');
                const end = text.lastIndexOf(']');
                if (start === -1 || end === -1 || end <= start) {
                    return [];
                }
                const data = JSON.parse(text.slice(start, end + 1));

                const exact = data.filter(item => item.url && this.urlsEqual(item.url, url));

                return exact.slice(0, 10).map(item => ({
                    title: item.title,
                    url: item.short_id_url && item.short_id_url.startsWith('http') ? item.short_id_url : `https://lobste.rs${item.short_id_url || ''}`,
                    score: item.score,
                    comments: item.comment_count,
                    author: typeof item.submitter_user === 'string' ? item.submitter_user : (item.submitter_user && item.submitter_user.username) || '',
                    tags: item.tags,
                    created: new Date(item.created_at).toLocaleDateString()
                }));
            } catch (error) {
                console.error('Lobsters search error:', error);
                return [];
            }
        }

        extractDomain(url) {
            try {
                const urlObj = new URL(url);
                return urlObj.hostname.replace(/^www\\./, '');
            } catch {
                return url;
            }
        }

        normalizeUrlForComparison(rawUrl) {
            try {
                const u = new URL(rawUrl);
                const hostname = u.hostname.replace(/^www\./, '').toLowerCase();
                // Normalize path: remove trailing slash except for root
                let pathname = u.pathname || '';
                if (pathname === '/') {
                    pathname = '';
                } else {
                    // Remove all trailing slashes without using regex to avoid escaping pitfalls
                    while (pathname.endsWith('/')) pathname = pathname.slice(0, -1);
                }
                const search = u.search || '';
                // Ignore hash fragments
                return `${hostname}${pathname}${search}`;
            } catch {
                // Best-effort: strip trailing slashes from a string
                let s = String(rawUrl || '');
                while (s.endsWith('/')) s = s.slice(0, -1);
                return s;
            }
        }

        urlsEqual(a, b) {
            return this.normalizeUrlForComparison(a) === this.normalizeUrlForComparison(b);
        }

        // Extract candidate URLs from free text and check if any equal the target url
        textMentionsUrl(text, targetUrl) {
            if (!text) return false;
            const domain = this.extractDomain(targetUrl).toLowerCase();
            const candidates = [];

            // 1) Absolute URLs
            const absRe = /(https?:\/\/[^\s)\]\}>'"`]+)/gi;
            for (const m of text.matchAll(absRe)) {
                candidates.push(m[1]);
            }
            
            // 2) www. or bare domain with path (only collect those matching the target domain to reduce noise)
            const bareRe = /(?:^|\s)((?:www\.)?[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}(?:\/[\w\-\.\/%#?=&+~:@]+)?)/g;
            for (const m of text.matchAll(bareRe)) {
                const s = (m[1] || '').trim();
                if (!s) continue;
                try {
                    // Deduce domain either via URL or naive split
                    let host = '';
                    try { host = new URL(s).hostname.toLowerCase(); } catch { host = s.split('/')[0].toLowerCase(); }
                    if (!host.includes(domain)) continue;
                    candidates.push(s);
                } catch {}
            }

            // Normalize candidates and compare
            for (const c of candidates) {
                // If candidate is scheme-less, temporarily add https:// to help URL parsing normalize properly
                const c2 = /^https?:\/\//i.test(c) ? c : `https://${c}`;
                if (this.urlsEqual(c2, targetUrl)) return true;
            }
            return false;
        }

        showLoading() {
            this.loading.style.display = 'block';
            this.results.innerHTML = '';
            this.searchBtn.disabled = true;
            this.searchBtn.textContent = 'Searching...';
        }

        hideLoading() {
            this.loading.style.display = 'none';
            this.searchBtn.disabled = false;
            this.searchBtn.textContent = 'Search Discussions';
        }

        showError(message) {
            this.results.innerHTML = `<div class="error">Error: ${message}</div>`;
        }

        displayResults(results) {
            const platforms = [
                { key: 'hackernews', name: 'Hacker News', class: 'hn', icon: 'üì∞' },
                { key: 'reddit', name: 'Reddit', class: 'reddit', icon: 'ü§ñ' },
                { key: 'lobsters', name: 'Lobsters', class: 'lobsters', icon: 'ü¶û' }
            ];

            const html = platforms.map(platform => {
                const platformResults = results[platform.key] || [];

                return `
                    <div class="platform-section">
                        <div class="platform-header ${platform.class}">
                            <span>${platform.icon}</span>
                            ${platform.name} (${platformResults.length})
                        </div>
                        <div class="platform-results">
                            ${platformResults.length > 0
                                ? platformResults.map(result => this.renderResult(result, platform.key)).join('')
                                : '<div class="no-results">No discussions found</div>'
                            }
                        </div>
                    </div>
                `;
            }).join('');

            this.results.innerHTML = html;
        }

        renderResult(result, platform) {
            const meta = [];

            if (platform === 'hackernews') {
                meta.push(`${result.points} points`);
                meta.push(`${result.comments} comments`);
                meta.push(`by ${result.author}`);
            } else if (platform === 'reddit') {
                meta.push(`r/${result.subreddit}`);
                meta.push(`${result.score} upvotes`);
                meta.push(`${result.comments} comments`);
            } else if (platform === 'lobsters') {
                meta.push(`${result.score} points`);
                meta.push(`${result.comments} comments`);
                if (result.tags) meta.push(`tags: ${result.tags.join(', ')}`);
            }

            meta.push(result.created);

            return `
                <div class="result-item">
                    <div class="result-title">
                        <a href="${result.url}" target="_blank">${result.title}</a>
                    </div>
                    <div class="result-meta">
                        ${meta.map(item => `<span>${item}</span>`).join('')}
                    </div>
                </div>
            `;
        }
    }

    // Initialize the app
    new URLDiscussionFinder();
</script>

</body>
</html>
